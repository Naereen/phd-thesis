%!TEX root = ../PhD_thesis__Lilian_Besson

% First chapter begins here
\chapter{SMPyBandits: a state-of-the-art open-source Python library to simulate multi-armed bandit problems}
\label{chapter:3}
\minitoc
\newpage
% Write miniTOC just after the title
\graphicspath{{2-Chapters/3-Chapter/Images/}}

This chapter is intended as a long version of the paper presenting SMPyBandits that I wrote in Summer 2018, see https://hal.inria.fr/hal-01840022


% ----------------------------------------------------------------------------
\section{Presentation of the library}
\label{sec:3:presentationLibrary}

I want to show what is SMPyBandits, what problems does it solve, what did I implement, how to use it.


% ----------------------------------------------------------------------------
\section{Experimental comparisons of state-of-the-art single-player algorithms}
\label{sec:3:reviewSPAlgorithms}

I want to show that SMPyBandits contains highly documented implementations of all the most important algorithms designed for stationary single-player multi-armed bandit.

I will include here formulas about the main algorithms (klUCB, MOSS, etc).
I will pick some problems (Bernoulli, Gaussian, others), with fixed means or ``Bayesian'' means (\ie, changing at each time) and I will run extensive numerical simulations to compare the main algorithms.

The take away message is: klUCB beats UCB, Thompson sampling is great too, all the others algorithms are less efficient or comparable, so we only use klUCB for all the rest of this thesis.

I will include graphs showing the mean regret $R_t$ as a function of time $t$, as well as histograms or boxplots showing the distribution of $R_T$.


% ----------------------------------------------------------------------------
\section{Some numerical experiments to compare time and memory costs of various algorithms}
\label{sec:3:timeAndMemoryCosts}

I want to show the real numerical costs in terms of computation time and storage requirement of the various algorithms for single-player bandits.

Maybe I can pick one simple problem family (\eg, evenly spaced in $[\varepsilon,1-\varepsilon]$), and run experiments for $T=1000,5000,10000$ etc, and $K=2,3,5,9,20,30,50,100,1000$ and show the evolution of time/memory as a function of $T$ and $K$.

The goal is to highlight that the simplest (but most efficient) algorithms have a memory cost bounded by $\bigO{K}$ and a time complexity at each time step $t\in[T]$ bounded by $\bigO{K}$, independent of $t$.


% ----------------------------------------------------------------------------
\section{An example of another model: rested or restless Markov models - FIXME maybe not included?}
\label{sec:3:markovModels}

Maybe if I have space at the end of this chapter, I can show another part of the library, maybe introduce the rested/restless Markov models (with maybe just one example) and show simulations in this model?

SMPyBandits also implemented sparse MAB models (with $s<K$ arms with a mean $\mu_i>0$ and $K-s$ arms with a mean $\mu_i \leq 0$), I could also present this model, the various algorithms designed to tackle it, and some numerical experiments.


% ----------------------------------------------------------------------------
\section{Conclusion of Chapter 3}
\label{sec:3:conclusion}

In this chapter, we saw...

Future works include...




% ----------------------------------------------------------------------------
\section{Appendix for Chapter 3}
\label{sec:3:appendix}

\begin{listing}[H]
\begin{minted}[linenos=true,numbersep=5pt,frame=lines,framesep=2mm]{python}
from SMPyBandits.Arms import Bernoulli
arms = [Bernoulli(0.1), Bernoulli(0.9)]

from SMPyBandits.Environment import MAB
my_MAB_problem = MAB(arms)
nbArms = my_MAB_problem.nbArms

from SMPyBandits.Policy import UCB
my_UCB_algo = UCB(nbArms, alpha=0.5)

horizon = 1000
for t in range(horizon):
    chosen_arm = my_UCB_algo.choice()
    observed_reward = my_MAB_problem.draw(chosen_arm)
    my_UCB_algo.getReward(chosen_arm, observed_reward)
...
\end{minted}
\caption{First example of code}
\label{lst:3:example}
\end{listing}

\subsection{Include a minimalist \texttt{main.py} file}

Include verbatim the file
\texttt{example\_of\_main\_singleplayer.py}

\begin{listing}[H]
% \lstinputlisting[language=Python]{2-Chapters/3-Chapter/src/example_of_main_singleplayer.py}
\inputminted[linenos=true,numbersep=5pt,frame=lines,framesep=2mm]{Python}{2-Chapters/3-Chapter/src/example_of_main_singleplayer.py}
\caption{Small example of \texttt{main.py} file}
\label{lst:3:main}
\end{listing}

\subsection{Include a minimalist \texttt{configuration.py} file}

Include verbatim the file
\texttt{example\_of\_configuration\_singleplayer.py}

\begin{listing}[H]
% \lstinputlisting[language=Python]{2-Chapters/3-Chapter/src/example_of_configuration_singleplayer.py}
\inputminted[linenos=true,numbersep=5pt,frame=lines,framesep=2mm]{Python}{2-Chapters/3-Chapter/src/example_of_configuration_singleplayer.py}
\caption{Small example of \texttt{configuration.py} file}
\label{lst:3:configuration}
\end{listing}


\subsection{Using multi-core to speed-up simulations}

Quickly explain the advantages and drawbacks of using Joblib and joblib.Parallel to run simulations on multiple cores of the same computer

Explain why I didn't try more on parallelisation (eg on Grid5000 or other large scale computer).
